package ppdz;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import rs.etf.pp1.symboltable.*;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.mj.runtime.Code;

parser code {:
	int statementBlocksCount = 0;
	int globalVariablesCount = 0;
	int globalConstantsCount = 0;
	int statementsInMainCount = 0;
	int fcallInMainCount = 0;
	int globalArrayDeclCount = 0;
	int functionDefinitionCount = 0;	
	int innerClassCount = 0;
	int innerClassMethodCount = 0;
	int instatiationStatementCount = 0;
	int newOperatorCount = 0;
	boolean arrayStarted = false;
	public Struct currentVarType = null;
	
	//public static void main(String[] args) throws java.lang.Exception {
	//	FileReader f = new FileReader(args[0]);
	//	Yylex skener = new Yylex(f);
	//	parser p = new parser(skener);
	//	Symbol s = p.parse();
	//}

	public void report_fatal_error(String message, Object info) throws java.lang.Exception {
		done_parsing();
		report_error(message, info);
	}

	public void syntax_error(Symbol cur_token) {
		report_error("\nSintaksna greska", cur_token);
	}

	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
		report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
	}

	public void report_error(String message, Object info) {
		StringBuilder msg = new StringBuilder(message);
		if(info instanceof Symbol) {
			msg.append(" na liniji ").append(((Symbol)info).left);
		}

		System.err.println(msg.toString());
	}

	public void report_info(String message) {
		System.out.println(message);
	}
	
	public static Obj insert_symbol(int symbol_type, String name, Struct var_type) {
		Obj ret = Tab.insert(symbol_type, name, var_type);
		return ret;
	}

	public static boolean isLvalueVariable(Obj obj) {
		return obj.getKind() == Obj.Var || obj.getKind() == Obj.Fld;
	}


	public Struct stringType = new Struct(Struct.Array);
	public Struct boolType = new Struct(5);
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	
	/*if(s != null && s.value != null) {
		System.out.println("\n" + s.toString() + " " + s.value.toString());
	}*/
	return s;
:}

action code {:
	private Obj currMethod = null;
	private Obj currClass = null;
	private LinkedList<Struct> currActPars = new LinkedList<Struct>();
	private boolean inMain = false;
	private boolean mainDetected = false;
	private boolean errorDetected = false;
	private Struct currType = null;
	private String currTypeName = null;

	public void addActualParam(Obj obj) {
		if (obj == null) {
			return;
		}

		if (currActPars == null) {
			currActPars = new LinkedList<Struct>();
		}

		currActPars.add(obj.getType());
	}

	public void checkActualParams(Obj func, int line) {
		if (func == null) {
			return;
		}
		
		int count = func.getLevel();

		if (func.getName().equals("len") || func.getName().equals("ord") || func.getName().equals("chd")) {
			currActPars = null;
			return;
		}

		// check numbers
		if (currActPars == null) {
			if (count > 0) {
				System.out.print("0 params, given more: ");
				printError(Message.SemanticError.wrongParams(func.getName(), line));
			}
			return;
		}
		
		if (currActPars.size() != count) {
			System.out.print("Different number of actual and formal params: ");
			printError(Message.SemanticError.wrongParams(func.getName(), line));
			currActPars = null;
			return;
		}
		
		ListIterator<Struct> it = currActPars.listIterator();
		for (Obj member : func.getLocalSymbols()) {
			if (count-- > 0) {
				Struct s = it.next();
				if (!s.compatibleWith(member.getType())) {
					System.out.print("Some argument not compatible: ");
					printError(Message.SemanticError.wrongParams(func.getName(), line));
				}
			}
		}

		currActPars = null;

	}
	
	public void generateFunctionCall(Obj func, int line) {
		if (func == null) {
			return;
		}

		checkActualParams(func, line);

		if (func.getName().equals("len")) {
			// Code.put(Code.arrayLength);
			return;
		}
	}
	
	public void printError(String error) {
		if (error == null)
			return;

		System.err.println(error);
		errorDetected = true;
	}

	public static class Message {
		private static class _SemanticError {
			private final String semErr = "Semantic error on line ";
			public String wrongType(String type, int line) { return semErr + line + ": Data type missmatch. Use valid value for '" + type + "'."; }
			public String noTypeErr(String type, int line) { return semErr + line + ": Type '" + type + "' has not been found in symbol table."; }
			public String typeErr(String type, int line) { return semErr + line + ": Name '" + type + "' is not a valid type."; }  
			public String alreadyDeclared(String name, int line) { return semErr + line + ": Name '" + name + "' has already been declared."; }
			public String nameNotDeclaredErr(String name, int line) { return semErr + line + ": Name '" + name + "' has not been declared."; }
			public String assignToConst(Obj obj, int line) { return semErr + line + ": Assigning to const variable '" + obj.getName() + "'." + objNodeToString(obj); }
			public String onlyInteger(int line) { return semErr + line + ": Only integer allowed."; }
			public String notObject(String name, int line) { return semErr + line + ": Cannot use '.' on non object type '" + name + "'."; }
			public String memberNotFound(String name, int line) { return semErr + line + ": Class member '" + name + "' not found."; }
			public String wrongParams(String func, int line) { return semErr + line + ": Function '" + func + "' call arguments don't match declaration."; }
			public String onlyBoolean(int line) { return semErr + line + ": Only boolean allowed."; }
			public String cannotCompare(int line) { return semErr + line + ": Cannot compare different data types."; }

			public final String noMainDetected = "Semantic error: void main() not found.";
		}
		
		private static class _SemanticMessage {
			public static String constVarDecl(Obj obj, int line) { return "Constant variable '" + obj.getName() + "' declared on line " + line + "." + objNodeToString(obj); }
			public static String globalVarDecl(Obj obj, int line) { return "Global variable '" + obj.getName() + "' declared on line " + line + "." + objNodeToString(obj); }
	        	public static String usingConstant(Obj obj, int line) { return "Using constant variable '" + obj.getName() + "' on line " + line + "." + objNodeToString(obj); }
	        	public static String usingGlobal(Obj obj, int line) { return "Using global variable '" + obj.getName() + "' on line " + line + "." + objNodeToString(obj); }
	        	public static String symbolFound(Obj obj, int line) { return "Found symbol '" + obj.getName() + "' on line " + line + "." + objNodeToString(obj); }
			public static String classDecl(Obj obj, int line) { return "Class '" + obj.getName() + "' declared on line " + line + "." + objNodeToString(obj); }
			public static String fieldDecl(Obj obj, int line) { return "Class field '" + obj.getName() + "' declared on line " + line + "." + objNodeToString(obj); }
}

		public static final _SemanticMessage SemanticMessage = new _SemanticMessage();
		public static final _SemanticError SemanticError = new _SemanticError();
	}

	 // Print obj node ----------------------------------------------------------------------------------------------
	    private static String objNodeToString(Obj obj)
	    {
	        if (obj == null) return null;

        	StringBuilder sb = new StringBuilder(" Obj node: ");

	        // kind
        	switch (obj.getKind()) 
	        {
	            case Obj.Con:  sb.append("Con "); break;
	            case Obj.Var:  sb.append("Var "); break;
	            case Obj.Type: sb.append("Type "); break;
	            case Obj.Meth: sb.append("Meth "); break;
	            case Obj.Fld:  sb.append("Fld "); break;
	            case Obj.Prog: sb.append("Prog "); break;

        	}
        
	        sb.append(obj.getName());
	        sb.append(": ");

        	// type 
	        switch (obj.getType().getKind()) 
        	{
	            case Struct.None:   sb.append("notype"); break;
	            case Struct.Int:    sb.append("int"); break;
	            case Struct.Char:   sb.append("char"); break;
	            case Struct.Class:  sb.append("class"); break;
	            case 5:             sb.append("bool"); break;
	            case Struct.Array:  sb.append("Arr of ");
            
                    switch (obj.getType().getElemType().getKind()) 
	            {
                                case Struct.None:   sb.append("notype"); break;
                                case Struct.Int:    sb.append("int"); break;
                                case Struct.Char:   sb.append("char"); break;
                                case Struct.Class:  sb.append("class"); break;
                                case 5:             sb.append("bool"); break;
                                default: break;
                    }
            
        	    default: break;
	        }

	        sb.append(", ");
	        sb.append(obj.getAdr());
        	sb.append(", ");
	        sb.append(obj.getLevel());

        	return sb.toString();
    	}

	
	// Add constant: const int = 1...
	void addConstant(String name, Obj con, int line) {
		if (name == null || con == null || currType == null || currTypeName == null) return;

		if (currType.getKind() != con.getType().getKind()) {
			printError(Message.SemanticError.wrongType(currTypeName, line));
			return;
		}
		
		// if name is declared name, print error
		if (isDeclared(name)) {
			printError(Message.SemanticError.alreadyDeclared(name, line));
			return;
		}
		//handle string type

		Obj obj = parser.insert_symbol(Obj.Con, name, con.getType());
		obj.setAdr(con.getAdr());
		parser.globalConstantsCount++;
		parser.report_info(Message.SemanticMessage.constVarDecl(obj, line));
	}

	// Add global: int x, xy[];
	void addGlobal(String name, int line, boolean isArray) {
		if (name == null || currType == null || currTypeName == null) return;

		// if name is declared, print error
		if (isDeclared(name)) {
			printError(Message.SemanticError.alreadyDeclared(name, line));
			return;
		}

		Obj temp = null;
		if (isArray) {
			temp = Tab.insert(Obj.Var, name, new Struct(Struct.Array, currType));
			parser.globalArrayDeclCount++;
		} else {
			temp = Tab.insert(Obj.Var, name, currType);
			parser.globalVariablesCount++;
		}

		parser.report_info(Message.SemanticMessage.globalVarDecl(temp, line));
		
	}

	// Add local variables
	void addLocal(String name, int line, boolean isArray) {
		if (name == null || currType == null || currMethod == null) {
			return;
		}
		
		if (!isDeclared(name)) {
			Obj temp = null;
			if (isArray) {
				Tab.insert(Obj.Var, name, new Struct(Struct.Array, currType));
			} else {
				Tab.insert(Obj.Var, name, currType);
			}
		} else {
			printError(Message.SemanticError.alreadyDeclared(name, line));
		}
	}

	// Add formal parameter to current scope
	void addFormalParam(String name, int line, boolean isArray) {
		if (name == null || currType == null || currMethod == null) return;
		
		if (isDeclared(name)) {
			printError(Message.SemanticError.alreadyDeclared(name, line));
		} else {
			Obj temp = null;
			
			if (isArray) {
				temp = Tab.insert(Obj.Var, name, new Struct(Struct.Array, currType));
			} else {
				temp = Tab.insert(Obj.Var, name, currType);
			}
			if (currMethod != null) {
				currMethod.setLevel(currMethod.getLevel() + 1);
				if (currClass != null) {
					temp.setAdr(temp.getAdr() + 1);
				}
			}
				
		}
	}

	// Add class field
	void addClassField(String name, int line, boolean isArray) {
		if (name == null || currClass == null || currType == null) {
			return;
		}

		if (!isDeclared(name)) {
			Obj temp = null;
			
			temp = Tab.insert(Obj.Fld, name, isArray ? new Struct(Struct.Array, currType) : currType);

			currClass.setAdr(currClass.getAdr() + 1);
			temp.setAdr(currClass.getAdr());

			parser.report_info(Message.SemanticMessage.fieldDecl(temp, line));
		} else {
			printError(Message.SemanticError.alreadyDeclared(name, line));
		}
	}

	boolean isDeclared(String name) {
		if (name  == null) {
			return true;
		}

		Obj temp = Tab.find(name);
		if (temp.getKind() == Obj.Type) {
			return true; //int int;
		}

		temp = Tab.currentScope.findSymbol(name);
		return temp != Tab.noObj && temp != null;
	}

:}

init with {:
	Tab.init();

	stringType.setElementType(Tab.charType);
	
	Tab.currentScope.addToLocals(new Obj (Obj.Type, "string", stringType));
	Tab.currentScope.addToLocals(new Obj (Obj.Type, "bool", boolType));
:}


terminal PROG, LBRACE, RBRACE, LPAREN, RPAREN, CONST, SEMI, ASSIGN, COMMA, VOID;
terminal LBRACKET, RBRACKET, CLASS, EXTENDS, WHILE;
terminal READ, BREAK, RETURN, PRINT, DO, IF, ELSE, INCREMENT, DECREMENT, AND, OR;
terminal DOT, MINUS, NEW, PLUS, EQUALS, NEQUALS, MORE, MOREQUAL, LESS, LESSEQUAL;
terminal TIMES, DIV, PERCENT;

// Const Literals
terminal Integer NUMBER;
terminal Character CHAR;
terminal String BOOLCONST;
terminal String STRCONST;

// Identifiers
terminal String IDENT;

non terminal Program, ConstDecl;
non terminal VarDecl, VarDeclList, ClassDecl, ConstDefList;
non terminal VarDefList, VarDef, VarMethodDeclList, MethodDecl;
non terminal Statement, StatementList, matched, unmatched, FormPars;
non terminal FormParam, LvalueOperator, Condition, Cond, ActPars;
non terminal CondFact, CondTerm, AddopTermList, Mulop;
non terminal FunctionDeclList, FunctionDecl, EndOfFunction;
non terminal GlobalDeclList, GlobalDecl, GlobalConstDecl, GlobalVarDecl, GlobalVarDefList, GlobalVarDef;
non terminal Extends, ClassVarDecl, ClassVarDefList, ClassVarDef;
non terminal String Ident;


non terminal Integer Relop, Addop;
// Semantic
non terminal Obj ProgramName, ConstLiteral, FuncName, IdentList, Designator, ClassName;
non terminal Obj Type, Expr, Term, Factor, FuncCall;

Program ::= PROG ProgramName:p GlobalDeclList LBRACE FunctionDeclList RBRACE {:
		Tab.chainLocalSymbols(p);
		Tab.closeScope();

		if (!mainDetected) {
			printError(Message.SemanticError.noMainDetected);
		}
	:}
	;

ProgramName ::= IDENT:pName {:
		RESULT = parser.insert_symbol(Obj.Prog, pName, Tab.noType);

		Tab.openScope();
	:}
	;

GlobalDeclList ::= GlobalDecl
		GlobalDeclList
		| /* epsilon */
		;

GlobalDecl ::= GlobalConstDecl
	| GlobalVarDecl
	| ClassDecl {:
		parser.innerClassCount++;
	:}
	;

GlobalConstDecl ::= CONST Type ConstDefList SEMI
		| CONST error SEMI
		;

ConstDefList ::= ConstDecl
		| ConstDecl COMMA ConstDefList
		;

ConstDecl ::= IDENT:name ASSIGN ConstLiteral:con {:
		addConstant(name, con, nameleft);
	:}
	;

ConstLiteral ::= NUMBER:n {:
			Obj con = new Obj(Obj.Con, "", Tab.intType);
			con.setAdr(n.intValue());
			RESULT = con;
		:}
		| CHAR:c {:
			Obj con = new Obj(Obj.Con, "", Tab.charType);
			con.setAdr(c.charValue());
			RESULT = con; 
		:}
		| BOOLCONST:b {:
			Obj con = new Obj(Obj.Con, "", parser.boolType);
			con.setAdr(b.equals("true") ? 1 : 0);
			RESULT = con;
		:}
		| STRCONST {:
			Obj con = new Obj(Obj.Con, "", parser.stringType);
			// Allocate on heap

			RESULT = con;
		:}
		;

GlobalVarDecl ::= Type GlobalVarDefList SEMI
		| Type error SEMI
		;

GlobalVarDefList ::= GlobalVarDef
		| GlobalVarDef COMMA GlobalVarDefList
		;

GlobalVarDef ::= Ident:id {:
			addGlobal(id, idleft, false);
		:}
		| Ident:id LBRACKET RBRACKET {:
			addGlobal(id, idleft, true);
		:}
		;

VarDecl ::= Type VarDefList SEMI
	| Type error SEMI
	| Type error LBRACE
	;

VarDefList ::= VarDef
		| VarDef COMMA VarDefList
		;

VarDef ::= Ident:n {: addLocal(n, nleft, false); :}
	| Ident:n {: addLocal(n, nleft, true); :} LBRACKET RBRACKET
	;

ClassDecl ::= CLASS ClassName:id Extends LBRACE VarMethodDeclList RBRACE {:
		if (id != null) {
			Tab.chainLocalSymbols(id.getType());
			Tab.closeScope();
		}

		currClass = null;
	:}
	| CLASS Ident error LBRACE VarMethodDeclList RBRACE
	| CLASS error RBRACE
	;

ClassName ::= IDENT:id {:
		Obj temp = null;
		
		if (!isDeclared(id)) {
			temp = new Obj(Obj.Type, id, new Struct(Struct.Class));

			// add class to the list

			Tab.currentScope.addToLocals(temp);
			Tab.openScope();

			parser.report_info(Message.SemanticMessage.classDecl(temp, idleft));

			temp.getType().setElementType(null);
			temp.setAdr(0);
		} else {
			printError(Message.SemanticError.alreadyDeclared(id, idleft));
		}


		currClass = temp;
	        RESULT = temp;
	:}
	;


Extends ::= EXTENDS Ident
	| /* epsilon */
	;

VarMethodDeclList ::= ClassVarDecl VarMethodDeclList
		| MethodDecl {:
			parser.innerClassMethodCount++;
		:} VarMethodDeclList
		| /* epsilon */
		;

ClassVarDecl ::= Type ClassVarDefList SEMI
		;

ClassVarDefList ::= ClassVarDef
		| ClassVarDef COMMA ClassVarDefList
		;

ClassVarDef ::= Ident:id {:
			addClassField(id, idleft, false);
		:}
		| Ident:id LBRACKET RBRACKET {:
			addClassField(id, idleft, true);
		:}
		;


MethodDecl ::= Type FuncName:m LPAREN FormPars RPAREN VarDeclList LBRACE {:
		if (m != null && currMethod != null) {
			Tab.chainLocalSymbols(currMethod);
		}

	:}
		 StatementList RBRACE EndOfFunction {:

			if (currMethod != null) {
				Tab.closeScope();
			}
			parser.statementBlocksCount++;
	:}
	| VOID {: currType = Tab.noType; :} FuncName:m LPAREN FormPars RPAREN VarDeclList LBRACE {:
		if (m != null && currMethod != null) {
			Tab.chainLocalSymbols(currMethod);
		}
	:}
	StatementList RBRACE EndOfFunction {:
		parser.statementBlocksCount++;
	:}
	;

FuncName ::= IDENT:fname {:
		
		currMethod = null;

		if(!isDeclared(fname)) {
			currMethod = Tab.insert(Obj.Meth, fname, currType);
			currMethod.setLevel(0);
			Tab.openScope();
		} else {
			printError(Message.SemanticError.alreadyDeclared(fname, fnameleft));
		}

		if (currMethod != null && fname.equals("main")) {
			inMain = true;
			mainDetected = true;
		}

		RESULT = currMethod;
	:}
	;

EndOfFunction ::= {:
			if (inMain == true) {
				inMain = false;
			}
			if (currMethod != null) {
				Tab.closeScope();
			}
			currMethod = null;
		:} 
		/* epsilon */
		;

FunctionDeclList ::= FunctionDecl {:
			parser.functionDefinitionCount++;
		:} FunctionDeclList
		| /* epsilon */
		;

FunctionDecl ::= MethodDecl
		;

VarDeclList ::= VarDecl VarDeclList
		| /* epsilon */
		;

FormPars ::= FormParam
	| FormParam COMMA FormPars
	| error
	| /* epsilon */
	;

FormParam ::= Type Ident:name {: addFormalParam(name, nameleft, false); :}
		| Type Ident:name LBRACKET RBRACKET {: addFormalParam(name, nameleft, true); :}
		;


StatementList ::= Statement {:
			if (inMain) {
				parser.statementsInMainCount++;
			}
		:}
		 StatementList
		| /* epsilon */
		;

Statement ::= matched
	| unmatched
	;

matched ::= Designator:d LvalueOperator  {:
		if (d != null) {
			if (!parser.isLvalueVariable(d)) {
				printError(Message.SemanticError.assignToConst(d, dleft));
			}
		}
		:} SEMI
		| Designator ASSIGN error SEMI
		| FuncCall LPAREN RPAREN SEMI
		| FuncCall:f LPAREN ActPars RPAREN SEMI {:
			//end of function call
			generateFunctionCall(f, fleft);

			if (f != null) {
				if (f.getType() != Tab.noType) {
					// pop return value
				}
			}
		:}
		| FuncCall LPAREN error RPAREN SEMI
		| READ LPAREN Designator RPAREN SEMI
		| BREAK SEMI 
		| RETURN SEMI
		| RETURN Expr SEMI
		| PRINT LPAREN Expr RPAREN SEMI
		| PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI
		| LBRACE StatementList RBRACE {:
			parser.statementBlocksCount++;
		:}
		| DO matched WHILE Cond SEMI
		| IF Cond matched ELSE matched
		| WHILE Cond matched
		;


unmatched ::= IF Cond Statement
	| IF Cond matched  ELSE unmatched
	| WHILE Cond unmatched
	;

Cond ::= LPAREN Condition RPAREN
	| LPAREN error RPAREN
	;

LvalueOperator ::= ASSIGN Expr
		| INCREMENT
		| DECREMENT
		;

ActPars ::= Expr:e {:
		addActualParam(e);	
	:}
	| Expr:e COMMA {:
		addActualParam(e);	
	:} ActPars
	| Expr COMMA error COMMA
	| Expr COMMA error RPAREN
	;

Condition ::= CondTerm
	| CondTerm OR Condition
	;

CondTerm ::= CondFact
	| CondFact AND CondTerm
	;

CondFact ::= Expr:expr {:
		//The lonely boolean
		Struct res = Tab.noType;
		if (expr != null) {
			if (!expr.getType().equals(parser.boolType)) {
				printError(Message.SemanticError.onlyBoolean(exprleft));
			} else {
				res = parser.boolType;
			}

			// Code gen bool == 1
			
		}

		RESULT = res;
	:}
	| Expr:expr1 Relop:op Expr:expr2 {:
		Struct res = Tab.noType;
		
		if (expr1 != null && expr2 != null) {
			if (op == Code.eq || op == Code.ne) {
				System.out.println("EXPR1: " + expr1.getName() + "   EXPR2: " + expr2.getName());
				if (!expr1.getType().equals(expr2.getType())) {
					printError(Message.SemanticError.cannotCompare(opleft));
				} else {
					// fix after while or if
				}
			} else {
				System.out.println("EXPR1: " + expr1.getName() + "   EXPR2: " + expr2.getName());
				if (!expr1.getType().equals(expr2.getType()) || expr1.getType() != Tab.intType) {
					printError(Message.SemanticError.cannotCompare(opleft));
				} else {
					// Fix after while or if
				}
			}
			res = parser.boolType;
		}
		RESULT = res;
		
	:}
	;

Expr ::= Expr:e Addop:op Term:t {:
		if (e != null && t != null && op != null) {
			if (e.getType().equals(t.getType()) && t.getType() == Tab.intType) {
				// Code.put(addop)
				RESULT = e;
			} else if (t.getType().equals(e.getType()) && t.getType() == parser.stringType && op == Code.add) {
				// Code.put nesto
				RESULT = e;
			} else {
				printError(Message.SemanticError.wrongType(currTypeName, eleft));
				RESULT = null;
			}
		}
	:}
	| MINUS Term:t {:
		if (t != null) {
			if (t.getType() != Tab.intType) {
				printError(Message.SemanticError.onlyInteger(tleft));
			}
			// Code.put(Code.neg);
		}
		RESULT = t;
	:}
	| Term:t  {:
		RESULT = t;
	:}
	;

Type ::= IDENT:t {:
		Obj obj = Tab.find(t);

		currType = null;

		if (obj == Tab.noObj) {
			printError(Message.SemanticError.noTypeErr(t, tleft));
			RESULT = null;
		} else {
			if (Obj.Type == obj.getKind()) {
				currType = obj.getType();
				currTypeName = t;
				RESULT = obj;
			} else {
				printError(Message.SemanticError.typeErr(t, tleft));
				RESULT = null;
			}
		}
	:}
	;

Term ::= Factor:f {:
		RESULT = f;
	:}
	| Factor:f Mulop Term:t {:
		if (t != null && f != null) {
			if (t.getType().equals(f.getType()) && t.getType() == Tab.intType) {
				// Code.put(Mulop); //Not yet
				RESULT = t;
			} else {
				RESULT = null;
				printError(Message.SemanticError.wrongType(currTypeName, tleft));
			}
		}
	:}
	;

Factor ::= NUMBER:i {:
		Obj obj = new Obj(Obj.Con, "", Tab.intType);

		obj.setAdr(i);
		// put on expression stack

		RESULT = obj;
	:}
	| CHAR:i {:
		Obj obj = new Obj(Obj.Con, "", Tab.charType);

		obj.setAdr(i);
		// put on expression stack
		RESULT = obj;
	:}
	| LPAREN Expr:e {:
		RESULT = e;
	:} RPAREN
	| BOOLCONST:i {:
		Obj obj = new Obj(Obj.Con, "", parser.boolType);
		
		obj.setAdr(i.equals("true") ? 1 : 0);
		// put on expression stack

		RESULT = obj;
	:}
	| STRCONST {:
		Obj obj = new Obj(Obj.Con, "", parser.stringType);
		
		// allocate on heap len bytes

		// address on stack

		RESULT = obj;
	:}
	| NEW Type:t {:
		if (t != null) {
			if (t.getType().getKind() != Struct.Class) {
				printError(Message.SemanticError.wrongType(t.getName(), tleft));
			} else {		
				parser.instatiationStatementCount++;
			}
		}
		RESULT = t;
	:}
	| NEW Type:t LBRACKET Expr:expr {:
		if (expr != null && expr.getType() != Tab.intType) {
			printError(Message.SemanticError.onlyInteger(exprleft));
		}
	:}
	RBRACKET {:
		RESULT = t;
	:}
	| Designator:d {:
		RESULT = d;
	:}
	| FuncCall:f LPAREN RPAREN {:
		RESULT = f;
	:}
	| FuncCall:f LPAREN ActPars RPAREN {:
		if (f != null) {
			generateFunctionCall(f, fleft);
		}
		RESULT = f;
	:}
	;

FuncCall ::= Designator:l {:
		if (inMain)
			parser.fcallInMainCount++;
		RESULT = l;
	:}
	;


Designator ::= IdentList:id {:
		RESULT = id;
	:}
	;

IdentList ::= IdentList:il DOT Ident:id {:
		Obj member = null;

		if (il != null) {
			if (il.getType().getKind() != Struct.Class) {
				printError(Message.SemanticError.notObject(il.getName(), illeft));
			} else {
				Struct type = il.getType();

				if (currClass != null) {
					member = Tab.currentScope.getOuter().findSymbol(id);
				}

				while(type != null && member == null) {
					for (Obj obj : type.getMembers()) {
						if (id.equals(obj.getName())) {
							member = obj;
							break;
						}
					}
					type = type.getElemType();
				}


			}

			if (member == null) {
				printError(Message.SemanticError.memberNotFound(id, illeft));
			} else {
				if (member.getKind() == Obj.Meth) {
					//set calling 
					System.out.println("Calling class method: " + id);
				}

				if (il.getKind() != Obj.Type) {
					// Code.load(il);
					System.out.println("Found class field or method on line " + illeft + ": '" + id + "'.");
				} else {
					if (member.getKind() == Obj.Fld || member.getKind() == Obj.Meth) {
						//
					}
				}
			}
		}

		RESULT = member;
	:}
	| IdentList:ident LBRACKET Expr:expr RBRACKET {:
		Obj obj = null;
		if (ident != null) {
			if (ident.getType().getKind() != Struct.Array) {
				printError(Message.SemanticError.wrongType(ident.getName(), identleft));
			} else {
				// Code.load(ident);
			}
		
		
			if (expr != null && expr.getType() != Tab.intType) {
				printError(Message.SemanticError.onlyInteger(exprleft));
			} else if (ident.getKind() == Struct.Array) {
				
				obj = new Obj(Obj.Elem, ident.getName(), ident.getType().getElemType());
				System.out.println("ObjNodeToString[x]: " + objNodeToString(obj));
			}
		}
		RESULT = obj;
	:}
	| IdentList LBRACKET error RBRACKET
	| Ident:id {:
		Obj obj = null;		
		
		// local
		obj = Tab.currentScope.findSymbol(id);

		// find in class
		if (obj == null && false /* currentClass != null */) {

		}

		// global
		if (obj == null) {
			obj = Tab.find(id);
		}

		// symbol not found
		if (obj == Tab.noObj || obj == null) {
			obj = null;
			printError(Message.SemanticError.nameNotDeclaredErr(id, idleft));
		} else if (obj.getKind() != Obj.Meth) {
			parser.report_info(Message.SemanticMessage.symbolFound(obj, idleft));
		}

		//Generate some code

		RESULT = obj;
	:}
	;

Ident ::= IDENT:i {:
		RESULT = i;
	:}
	;

Relop ::= EQUALS {: RESULT = Code.eq; :}
	| NEQUALS {: RESULT = Code.ne; :}
	| MORE {: RESULT = Code.gt; :}
	| MOREQUAL {: RESULT = Code.ge; :}
	| LESS {: RESULT = Code.lt; :}
	| LESSEQUAL {: RESULT = Code.le; :}
	;

Addop ::= PLUS {: RESULT =  Code.add; :}
	| MINUS {: RESULT = Code.sub; :}
	;

Mulop ::= TIMES {: RESULT = Code.mul; :}
	| DIV {: RESULT = Code.div; :}
	| PERCENT {: RESULT = Code.rem; :}
	;


