package ppdz;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import rs.etf.pp1.symboltable.*;
import rs.etf.pp1.symboltable.concepts.*;

parser code {:
	int statementBlocksCount = 0;
	int globalVariablesCount = 0;
	int globalConstantsCount = 0;
	int statementsInMainCount = 0;
	int fcallInMainCount = 0;
	int globalArrayDeclCount = 0;
	int functionDefinitionCount = 0;	
	int innerClassCount = 0;
	int innerClassMethodCount = 0;
	int instatiationStatementCount = 0;
	boolean arrayStarted = false;
	public Struct currentVarType = null;

	//public static void main(String[] args) throws java.lang.Exception {
	//	FileReader f = new FileReader(args[0]);
	//	Yylex skener = new Yylex(f);
	//	parser p = new parser(skener);
	//	Symbol s = p.parse();
	//}

	public void report_fatal_error(String message, Object info) throws java.lang.Exception {
		done_parsing();
		report_error(message, info);
	}

	public void syntax_error(Symbol cur_token) {
		report_error("\nSintaksna greska", cur_token);
	}

	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
		report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
	}

	public void report_error(String message, Object info) {
		StringBuilder msg = new StringBuilder(message);
		if(info instanceof Symbol) {
			msg.append(" na liniji ").append(((Symbol)info).left);
		}

		System.err.println(msg.toString());
	}

	public void report_info(String message) {
		System.out.println(message);
	}
	
	public static Obj insert_symbol(int symbol_type, String name, Struct var_type) {
		Obj ret = Tab.insert(symbol_type, name, var_type);
		return ret;
	}

	public static boolean isLvalueVariable(Obj obj) {
		return obj.getKind() == Obj.Var || obj.getKind() == Obj.Fld;
	}


	public Struct stringType = new Struct(Struct.Array);
	public Struct boolType = new Struct(5);
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	
	/*if(s != null && s.value != null) {
		System.out.println("\n" + s.toString() + " " + s.value.toString());
	}*/
	return s;
:}

action code {:
	private Obj currMethod = null;
	private boolean inMain = false;
	private boolean mainDetected = false;
	private boolean errorDetected = false;
	private Struct currType = null;
	private String currTypeName = null;

	public void printError(String error) {
		if (error == null)
			return;

		System.err.println(error);
		errorDetected = true;
	}

	public static class Message {
		private static class _SemanticError {
			private final String semErr = "Semantic error on line ";
			public String wrongType(String type, int line) { return semErr + line + ": Data type missmatch. Use valid value for '" + type + "'."; }
			public String noTypeErr(String type, int line) { return semErr + line + ": Type '" + type + "' has not been found in symbol table."; }
			public String typeErr(String type, int line) { return semErr + line + ": Name '" + type + "' is not a valid type."; }  
			public String alreadyDeclared(String name, int line) { return semErr + line + ": Name '" + name + "' has already been declared."; }
			public String nameNotDeclaredErr(String name, int line) { return semErr + line + ": Name '" + name + "' has not been declared."; }
			public final String noMainDetected = "Semantic error: void main() not found.";
		}
		
		private static class _SemanticMessage {
			public static String constVarDecl(Obj obj, int line) { return "Constant variable '" + obj.getName() + "' declared on line " + line + "." + objNodeToString(obj); }
			public static String globalVarDecl(Obj obj, int line) { return "Global variable '" + obj.getName() + "' declared on line " + line + "." + objNodeToString(obj); }
	        	public static String usingConstant(Obj obj, int line) { return "Using constant variable '" + obj.getName() + "' on line " + line + "." + objNodeToString(obj); }
	        	public static String usingGlobal(Obj obj, int line) { return "Using global variable '" + obj.getName() + "' on line " + line + "." + objNodeToString(obj); }
	        	public static String symbolFound(Obj obj, int line) { return "Found symbol '" + obj.getName() + "' on line " + line + "." + objNodeToString(obj); }
		}

		public static final _SemanticMessage SemanticMessage = new _SemanticMessage();
		public static final _SemanticError SemanticError = new _SemanticError();
	}

	 // Print obj node ----------------------------------------------------------------------------------------------
	    private static String objNodeToString(Obj obj)
	    {
	        if (obj == null) return null;

        	StringBuilder sb = new StringBuilder(" Obj node: ");

	        // kind
        	switch (obj.getKind()) 
	        {
	            case Obj.Con:  sb.append("Con "); break;
	            case Obj.Var:  sb.append("Var "); break;
	            case Obj.Type: sb.append("Type "); break;
	            case Obj.Meth: sb.append("Meth "); break;
	            case Obj.Fld:  sb.append("Fld "); break;
	            case Obj.Prog: sb.append("Prog "); break;

        	}
        
	        sb.append(obj.getName());
	        sb.append(": ");

        	// type 
	        switch (obj.getType().getKind()) 
        	{
	            case Struct.None:   sb.append("notype"); break;
	            case Struct.Int:    sb.append("int"); break;
	            case Struct.Char:   sb.append("char"); break;
	            case Struct.Class:  sb.append("class"); break;
	            case 5:             sb.append("bool"); break;
	            case Struct.Array:  sb.append("Arr of ");
            
                    switch (obj.getType().getElemType().getKind()) 
	            {
                                case Struct.None:   sb.append("notype"); break;
                                case Struct.Int:    sb.append("int"); break;
                                case Struct.Char:   sb.append("char"); break;
                                case Struct.Class:  sb.append("class"); break;
                                case 5:             sb.append("bool"); break;
                                default: break;
                    }
            
        	    default: break;
	        }

	        sb.append(", ");
	        sb.append(obj.getAdr());
        	sb.append(", ");
	        sb.append(obj.getLevel());

        	return sb.toString();
    	}

	
	// Add constant: const int = 1...
	void addConstant(String name, Obj con, int line) {
		if (name == null || con == null || currType == null || currTypeName == null) return;

		if (currType.getKind() != con.getType().getKind()) {
			printError(Message.SemanticError.wrongType(currTypeName, line));
			return;
		}
		
		// if name is declared name, print error
		if (isDeclared(name)) {
			printError(Message.SemanticError.alreadyDeclared(name, line));
			return;
		}
		//handle string type

		Obj obj = parser.insert_symbol(Obj.Con, name, con.getType());
		obj.setAdr(con.getAdr());
		parser.globalConstantsCount++;
		parser.report_info(Message.SemanticMessage.constVarDecl(obj, line));
	}

	// Add global: int x, xy[];
	void addGlobal(String name, int line, boolean isArray) {
		if (name == null || currType == null || currTypeName == null) return;

		// if name is declared, print error
		if (isDeclared(name)) {
			printError(Message.SemanticError.alreadyDeclared(name, line));
			return;
		}

		Obj temp = null;
		if (isArray) {
			temp = Tab.insert(Obj.Var, name, new Struct(Struct.Array, currType));
			parser.globalArrayDeclCount++;
		} else {
			temp = Tab.insert(Obj.Var, name, currType);
			parser.globalVariablesCount++;
		}

		parser.report_info(Message.SemanticMessage.globalVarDecl(temp, line));
		
	}

	// Add local variables
	void addLocal(String name, int line, boolean isArray) {
		if (name == null || currType == null || currMethod == null) {
			return;
		}
		
		if (!isDeclared(name)) {
			Obj temp = null;
			if (isArray) {
				Tab.insert(Obj.Var, name, new Struct(Struct.Array, currType));
			} else {
				Tab.insert(Obj.Var, name, currType);
			}
		} else {
			printError(Message.SemanticError.alreadyDeclared(name, line));
		}
	}

	// Add formal parameter to current scope
	void addFormalParam(String name, int line, boolean isArray) {
		if (name == null || currType == null || currMethod == null) return;
		
		if (isDeclared(name)) {
			printError(Message.SemanticError.alreadyDeclared(name, line));
		} else {
			Obj temp = null;
			
			if (isArray) {
				temp = Tab.insert(Obj.Var, name, new Struct(Struct.Array, currType));
			} else {
				temp = Tab.insert(Obj.Var, name, currType);
			}
			if (currMethod != null) {
				currMethod.setLevel(currMethod.getLevel() + 1);

				//For class too
			}
				
		}
	}

	boolean isDeclared(String name) {
		if (name  == null) {
			return true;
		}

		Obj temp = Tab.find(name);
		if (temp.getKind() == Obj.Type) {
			return true; //int int;
		}

		temp = Tab.currentScope.findSymbol(name);
		return temp != Tab.noObj && temp != null;
	}

:}

init with {:
	Tab.init();

	stringType.setElementType(Tab.charType);
	
	Tab.currentScope.addToLocals(new Obj (Obj.Type, "string", stringType));
	Tab.currentScope.addToLocals(new Obj (Obj.Type, "bool", boolType));
:}


terminal PROG, LBRACE, RBRACE, LPAREN, RPAREN, CONST, SEMI, ASSIGN, COMMA, VOID;
terminal LBRACKET, RBRACKET, CLASS, EXTENDS, WHILE;
terminal READ, BREAK, RETURN, PRINT, DO, IF, ELSE, INCREMENT, DECREMENT, AND, OR;
terminal DOT, MINUS, NEW, PLUS, EQUALS, NEQUALS, MORE, MOREQUAL, LESS, LESSEQUAL;
terminal TIMES, DIV, PERCENT;

// Const Literals
terminal Integer NUMBER;
terminal Character CHAR;
terminal String BOOLCONST;
terminal String STRCONST;

// Identifiers
terminal String IDENT;

non terminal Program, ConstDecl;
non terminal VarDecl, VarDeclList, ClassDecl, ConstDefList;
non terminal VarDefList, VarDef, VarMethodDeclList, MethodDecl;
non terminal Statement, StatementList, matched, unmatched, FormPars;
non terminal FormParam, LvalueOperator, Condition, Cond, ActPars;
non terminal CondFact, CondTerm, Relop, Addop, AddopTermList, Mulop;
non terminal FunctionDeclList, FunctionDecl, EndOfFunction;
non terminal GlobalDeclList, GlobalDecl, GlobalConstDecl, GlobalVarDecl, GlobalVarDefList, GlobalVarDef;
non terminal Extends, FuncCall;
non terminal String Ident;

// Semantic
non terminal Obj ProgramName, ConstLiteral, FuncName, IdentList, Designator;
non terminal Type, Expr, Term, Factor;

Program ::= PROG ProgramName:p GlobalDeclList LBRACE FunctionDeclList RBRACE {:
		Tab.chainLocalSymbols(p);
		Tab.closeScope();

		if (!mainDetected) {
			printError(Message.SemanticError.noMainDetected);
		}
	:}
	;

ProgramName ::= IDENT:pName {:
		RESULT = parser.insert_symbol(Obj.Prog, pName, Tab.noType);

		Tab.openScope();
	:}
	;

GlobalDeclList ::= GlobalDecl
		GlobalDeclList
		| /* epsilon */
		;

GlobalDecl ::= GlobalConstDecl
	| GlobalVarDecl
	| ClassDecl {:
		parser.innerClassCount++;
	:}
	;

GlobalConstDecl ::= CONST Type ConstDefList SEMI
		| CONST error SEMI
		;

ConstDefList ::= ConstDecl
		| ConstDecl COMMA ConstDefList
		;

ConstDecl ::= IDENT:name ASSIGN ConstLiteral:con {:
		addConstant(name, con, nameleft);
	:}
	;

ConstLiteral ::= NUMBER:n {:
			Obj con = new Obj(Obj.Con, "", Tab.intType);
			con.setAdr(n.intValue());
			RESULT = con;
		:}
		| CHAR:c {:
			Obj con = new Obj(Obj.Con, "", Tab.charType);
			con.setAdr(c.charValue());
			RESULT = con; 
		:}
		| BOOLCONST:b {:
			Obj con = new Obj(Obj.Con, "", parser.boolType);
			con.setAdr(b.equals("true") ? 1 : 0);
			RESULT = con;
		:}
		| STRCONST {:
			Obj con = new Obj(Obj.Con, "", parser.stringType);
			// Allocate on heap

			RESULT = con;
		:}
		;

GlobalVarDecl ::= Type GlobalVarDefList SEMI
		| Type error SEMI
		;

GlobalVarDefList ::= GlobalVarDef
		| GlobalVarDef COMMA GlobalVarDefList
		;

GlobalVarDef ::= Ident:id {:
			addGlobal(id, idleft, false);
		:}
		| Ident:id LBRACKET RBRACKET {:
			addGlobal(id, idleft, true);
		:}
		;

VarDecl ::= Type VarDefList SEMI
	| Type error SEMI
	| Type error LBRACE
	;

VarDefList ::= VarDef
		| VarDef COMMA VarDefList
		;

VarDef ::= Ident:n {: addLocal(n, nleft, false); :}
	| Ident:n {: addLocal(n, nleft, true); :} LBRACKET RBRACKET
	;

ClassDecl ::= CLASS Ident Extends LBRACE VarMethodDeclList RBRACE
	| CLASS Ident error LBRACE VarMethodDeclList RBRACE
	| CLASS error RBRACE
	;

Extends ::= EXTENDS Ident
	| /* epsilon */
	;

VarMethodDeclList ::= VarDecl VarMethodDeclList
		| MethodDecl {:
			parser.innerClassMethodCount++;
		:} VarMethodDeclList
		| /* epsilon */
		;


MethodDecl ::= Type FuncName:m LPAREN FormPars RPAREN VarDeclList LBRACE {:
		if (m != null && currMethod != null) {
			Tab.chainLocalSymbols(currMethod);
		}

	:}
		 StatementList RBRACE EndOfFunction {:

			if (currMethod != null) {
				Tab.closeScope();
			}
			parser.statementBlocksCount++;
	:}
	| VOID {: currType = Tab.noType; :} FuncName:m LPAREN FormPars RPAREN VarDeclList LBRACE {:
		if (m != null && currMethod != null) {
			Tab.chainLocalSymbols(currMethod);
		}
	:}
	StatementList RBRACE EndOfFunction {:
		parser.statementBlocksCount++;
	:}
	;

FuncName ::= IDENT:fname {:
		
		currMethod = null;

		if(!isDeclared(fname)) {
			currMethod = Tab.insert(Obj.Meth, fname, currType);
			currMethod.setLevel(0);
			Tab.openScope();
		} else {
			printError(Message.SemanticError.alreadyDeclared(fname, fnameleft));
		}

		if (currMethod != null && fname.equals("main")) {
			inMain = true;
			mainDetected = true;
		}

		RESULT = currMethod;
	:}
	;

EndOfFunction ::= {:
			if (inMain == true) {
				inMain = false;
			}
			if (currMethod != null) {
				Tab.closeScope();
			}
			currMethod = null;
		:} 
		/* epsilon */
		;

FunctionDeclList ::= FunctionDecl {:
			parser.functionDefinitionCount++;
		:} FunctionDeclList
		| /* epsilon */
		;

FunctionDecl ::= MethodDecl
		;

VarDeclList ::= VarDecl VarDeclList
		| /* epsilon */
		;

FormPars ::= FormParam
	| FormParam COMMA FormPars
	| error
	| /* epsilon */
	;

FormParam ::= Type Ident:name {: addFormalParam(name, nameleft, false); :}
		| Type Ident:name LBRACKET RBRACKET {: addFormalParam(name, nameleft, true); :}
		;


StatementList ::= Statement {:
			if (inMain) {
				parser.statementsInMainCount++;
			}
		:}
		 StatementList
		| /* epsilon */
		;

Statement ::= matched
	| unmatched
	;

matched ::= Designator:d LvalueOperator  {:
		if (!parser.isLvalueVariable(d)) {
			System.out.println("Error (" + dleft + "): Variable '" + d.getName() + "' is immutable.");
		}
		:} SEMI
		| Designator ASSIGN error SEMI
		| FuncCall LPAREN RPAREN SEMI
		| FuncCall LPAREN ActPars RPAREN SEMI
		| FuncCall LPAREN error RPAREN SEMI
		| READ LPAREN Designator RPAREN SEMI
		| BREAK SEMI 
		| RETURN SEMI
		| RETURN Expr SEMI
		| PRINT LPAREN Expr RPAREN SEMI
		| PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI
		| LBRACE StatementList RBRACE {:
			parser.statementBlocksCount++;
		:}
		| DO matched WHILE Cond SEMI
		| IF Cond matched ELSE matched
		| WHILE Cond matched
		;


unmatched ::= IF Cond Statement
	| IF Cond matched  ELSE unmatched
	| WHILE Cond unmatched
	;

Cond ::= LPAREN Condition RPAREN
	| LPAREN error RPAREN
	;

LvalueOperator ::= ASSIGN Expr
		| INCREMENT
		| DECREMENT
		;

ActPars ::= Expr
	| Expr COMMA ActPars
	| Expr COMMA error COMMA
	| Expr COMMA error RPAREN
	;

Condition ::= CondTerm
	| CondTerm OR Condition
	;

CondTerm ::= CondFact
	| CondFact AND CondTerm
	;

CondFact ::= Expr 
	| Expr Relop Expr
	;

Expr ::= Expr Addop Term

	| MINUS Term:t {:
		RESULT = t;
	:}
	| Term:t  {:
		RESULT = t;
	:}
	;

Type ::= IDENT:t {:
		Obj obj = Tab.find(t);

		currType = null;

		if (obj == Tab.noObj) {
			printError(Message.SemanticError.noTypeErr(t, tleft));
			RESULT = null;
		} else {
			if (Obj.Type == obj.getKind()) {
				currType = obj.getType();
				currTypeName = t;
				RESULT = obj;
			} else {
				printError(Message.SemanticError.typeErr(t, tleft));
				RESULT = null;
			}
		}
	:}
	;

Term ::= Factor
	| Factor Mulop Term
	;

Factor ::= NUMBER:i {:
		Obj obj = new Obj(Obj.Con, "", Tab.intType);

		obj.setAdr(i);
		// put on expression stack

		RESULT = obj;
	:}
	| CHAR:i {:
		Obj obj = new Obj(Obj.Con, "", Tab.charType);

		obj.setAdr(i);
		// put on expression stack
		RESULT = obj;
	:}
	| LPAREN Expr:e {:
		RESULT = e;
	:} RPAREN
	| BOOLCONST:i {:
		Obj obj = new Obj(Obj.Con, "", parser.boolType);
		
		obj.setAdr(i.equals("true") ? 1 : 0);
		// put on expression stack

		RESULT = obj;
	:}
	| STRCONST {:
		Obj obj = new Obj(Obj.Con, "", parser.stringType);
		
		// allocate on heap len bytes

		// address on stack

		RESULT = obj;
	:}
	| NEW Type:t {:
		RESULT = t;
	:}
	| NEW Type:t LBRACKET Expr RBRACKET {:
		RESULT = t;
	:}
	| Designator:d {:
		RESULT = d;
	:}
	| FuncCall:f LPAREN RPAREN {:
		RESULT = f;
	:}
	| FuncCall:f LPAREN ActPars RPAREN {:
		RESULT = f;
	:}
	;

FuncCall ::= Designator:l {:
		if (inMain)
			parser.fcallInMainCount++;
	:}
	;


Designator ::= IdentList:id {:
		RESULT = id;
	:}
	;

IdentList ::= IdentList DOT Ident:id {:
		// Currently RESULT = Obj.noObj
		RESULT = Tab.noObj;
	:}
	| IdentList LBRACKET Expr RBRACKET
	| IdentList LBRACKET error RBRACKET
	| Ident:id {:
		Obj obj = null;		
		
		// local
		obj = Tab.currentScope.findSymbol(id);

		// find in class
		if (obj == null && false /* currentClass != null */) {

		}

		// global
		if (obj == null) {
			obj = Tab.find(id);
		}

		// symbol not found
		if (obj == Tab.noObj || obj == null) {
			obj = null;
			printError(Message.SemanticError.nameNotDeclaredErr(id, idleft));
		} else if (obj.getKind() != Obj.Meth) {
			parser.report_info(Message.SemanticMessage.symbolFound(obj, idleft));
		}

		//Generate some code

		RESULT = obj;
	:}
	;

Ident ::= IDENT:i {:
		RESULT = i;
	:}
	;

Relop ::= EQUALS
	| NEQUALS
	| MORE
	| MOREQUAL
	| LESS
	| LESSEQUAL
	;

Addop ::= PLUS
	| MINUS
	;

Mulop ::= TIMES
	| DIV
	| PERCENT
	;


