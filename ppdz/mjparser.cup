package ppdz;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import rs.etf.pp1.symboltable.*;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.mj.runtime.Code;

parser code {:
	int statementBlocksCount = 0;
	int globalVariablesCount = 0;
	int globalConstantsCount = 0;
	int statementsInMainCount = 0;
	int fcallInMainCount = 0;
	int globalArrayDeclCount = 0;
	int functionDefinitionCount = 0;	
	int innerClassCount = 0;
	int innerClassMethodCount = 0;
	int instatiationStatementCount = 0;
	int newOperatorCount = 0;
	boolean arrayStarted = false;
	public Struct currentVarType = null;
	public static boolean errorDetected = false;
	//public static void main(String[] args) throws java.lang.Exception {
	//	FileReader f = new FileReader(args[0]);
	//	Yylex skener = new Yylex(f);
	//	parser p = new parser(skener);
	//	Symbol s = p.parse();
	//}

	public void report_fatal_error(String message, Object info) throws java.lang.Exception {
		done_parsing();
		report_error(message, info);
	}

	public void syntax_error(Symbol cur_token) {
		report_error("\nSintaksna greska", cur_token);
	}

	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
		report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
	}

	public void report_error(String message, Object info) {
		StringBuilder msg = new StringBuilder(message);
		if(info instanceof Symbol) {
			msg.append(" na liniji ").append(((Symbol)info).left);
		}

		System.err.println(msg.toString());
	}

	public void report_info(String message) {
		System.out.println(message);
	}
	
	public static Obj insert_symbol(int symbol_type, String name, Struct var_type) {
		Obj ret = Tab.insert(symbol_type, name, var_type);
		return ret;
	}

	public static boolean isLvalueVariable(Obj obj) {
		return obj.getKind() == Obj.Var || obj.getKind() == Obj.Fld || obj.getKind() == Obj.Elem;
	}


	public Struct stringType = new Struct(Struct.Array);
	public Struct boolType = new Struct(5);
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	
	/*if(s != null && s.value != null) {
		System.out.println("\n" + s.toString() + " " + s.value.toString());
	}*/
	return s;
:}

action code {:
	Deque<Obj> callingObjAddressStack = new ArrayDeque<Obj>();
	
	public class StringCodeBuffer {
		/**
		 * @author Marin Markic
		 *
		 */
		final int BUFFSIZE = 2048;
		private byte[] buffer = new byte[BUFFSIZE];
		public int pc = 0;
		
		public StringCodeBuffer() {}
		
		
		public void put (int x)  
		{
			if (pc < BUFFSIZE)
				buffer[pc++] = (byte)x;
		}
		
		public void put2 (int x) { put(x>>8); put(x); }
		 
		public void put4 (int x) { put2(x>>16); put2(x); }

		public void loadConst (int n) 
		{
		    if (0 <= n && n <= 5) put(Code.const_n+n);
		    else if (n == -1) put(Code.const_m1);
		    else  
		    { 
			put(Code.const_); 
			put4(n); 
		    }
		}
		
		public int size() { return pc; }
		
		public byte [] getBuffer() { return buffer; }

	}
	
	private Obj currMethod = null;
	private Obj currClass = null;
	private LinkedList<Struct> currActPars = new LinkedList<Struct>();
	private boolean inMain = false;
	private boolean mainDetected = false;
	private Struct currType = null;
	private String currTypeName = null;
	private boolean returnFound = false;
	private StringCodeBuffer StringCode = new StringCodeBuffer();
	private boolean isFunctionCall = false;
	public void addActualParam(Obj obj) {
		if (obj == null) {
			return;
		}

		if (currActPars == null) {
			currActPars = new LinkedList<Struct>();
		}

		currActPars.add(obj.getType());
	}

	public void checkActualParams(Obj func, int line) {
		if (func == null) {
			return;
		}
		
		int count = func.getLevel();

		if (func.getName().equals("len") || func.getName().equals("ord") || func.getName().equals("chd")) {
			currActPars = null;
			return;
		}

		// check numbers
		if (currActPars == null) {
			if (count > 0) {
				System.out.print("0 params, given more: ");
				printError(Message.SemanticError.wrongParams(func.getName(), line));
			}
			return;
		}
		
		if (currActPars.size() != count) {
			System.out.print("Different number of actual and formal params: ");
			printError(Message.SemanticError.wrongParams(func.getName(), line));
			currActPars = null;
			return;
		}
		
		ListIterator<Struct> it = currActPars.listIterator();
		for (Obj member : func.getLocalSymbols()) {
			if (count-- > 0) {
				Struct s = it.next();
				if (!s.compatibleWith(member.getType())) {
					System.out.print("Some argument not compatible: ");
					printError(Message.SemanticError.wrongParams(func.getName(), line));
				}
			}
		}

		currActPars = null;

	}
	
	public void generateFunctionCall(Obj func, int line) {
		if (func == null) {
			return;
		}

		checkActualParams(func, line);

		if (func.getName().equals("len")) {
			Code.put(Code.arraylength);
			return;
		}

		int destAdr = func.getAdr() - Code.pc;
		Code.put(Code.call);
		Code.put2(destAdr);
	}
	
	public void printError(String error) {
		if (error == null)
			return;

		System.err.println(error);
		parser.errorDetected = true;
	}

	public static class Message {
		private static class _SemanticError {
			private final String semErr = "Semantic error on line ";
			public String wrongType(String type, int line) { return semErr + line + ": Data type missmatch. Use valid value for '" + type + "'."; }
			public String noTypeErr(String type, int line) { return semErr + line + ": Type '" + type + "' has not been found in symbol table."; }
			public String typeErr(String type, int line) { return semErr + line + ": Name '" + type + "' is not a valid type."; }  
			public String alreadyDeclared(String name, int line) { return semErr + line + ": Name '" + name + "' has already been declared."; }
			public String nameNotDeclaredErr(String name, int line) { return semErr + line + ": Name '" + name + "' has not been declared."; }
			public String assignToConst(Obj obj, int line) { return semErr + line + ": Assigning to const variable '" + obj.getName() + "'." + objNodeToString(obj); }
			public String onlyInteger(int line) { return semErr + line + ": Only integer allowed."; }
			public String notObject(String name, int line) { return semErr + line + ": Cannot use '.' on non object type '" + name + "'."; }
			public String memberNotFound(String name, int line) { return semErr + line + ": Class member '" + name + "' not found."; }
			public String wrongParams(String func, int line) { return semErr + line + ": Function '" + func + "' call arguments don't match declaration."; }
			public String onlyBoolean(int line) { return semErr + line + ": Only boolean allowed."; }
			public String cannotCompare(int line) { return semErr + line + ": Cannot compare different data types."; }
			public String selfInheritance(int line) { return semErr + line + ": Self inheritance is ambiguous."; }
			public String mainFunctionErr(int line) { return semErr + line + ": Main function declaration error."; }
			public String wrongRetValue(String func, int line) { return semErr + line + ": Return statement doesn't match function '" + func + "' definition."; }
			public String notFunction(String ident, int line) { return semErr + line + ": Designator '" + ident + "' is not a function or method."; }

			public final String noMainDetected = "Semantic error: void main() not found.";
		}
		
		private static class _SemanticMessage {
			public static String constVarDecl(Obj obj, int line) { return "Constant variable '" + obj.getName() + "' declared on line " + line + "." + objNodeToString(obj); }
			public static String globalVarDecl(Obj obj, int line) { return "Global variable '" + obj.getName() + "' declared on line " + line + "." + objNodeToString(obj); }
	        	public static String usingConstant(Obj obj, int line) { return "Using constant variable '" + obj.getName() + "' on line " + line + "." + objNodeToString(obj); }
	        	public static String usingGlobal(Obj obj, int line) { return "Using global variable '" + obj.getName() + "' on line " + line + "." + objNodeToString(obj); }
	        	public static String symbolFound(Obj obj, int line) { return "Found symbol '" + obj.getName() + "' on line " + line + "." + objNodeToString(obj); }
			public static String classDecl(Obj obj, int line) { return "Class '" + obj.getName() + "' declared on line " + line + "." + objNodeToString(obj); }
			public static String fieldDecl(Obj obj, int line) { return "Class field '" + obj.getName() + "' declared on line " + line + "." + objNodeToString(obj); }
			public static String functionCalled(String func, int line) { return "Calling '" + func + "' function on line " + line + "."; }
			public static String methodCalled(String meth, int line) { return "Calling '" + meth + "' method on line " + line + "."; }


}

		public static final _SemanticMessage SemanticMessage = new _SemanticMessage();
		public static final _SemanticError SemanticError = new _SemanticError();
	}

	 // Print obj node ----------------------------------------------------------------------------------------------
	    private static String objNodeToString(Obj obj)
	    {
	        if (obj == null) return null;

        	StringBuilder sb = new StringBuilder(" Obj node: ");

	        // kind
        	switch (obj.getKind()) 
	        {
	            case Obj.Con:  sb.append("Con "); break;
	            case Obj.Var:  sb.append("Var "); break;
	            case Obj.Type: sb.append("Type "); break;
	            case Obj.Meth: sb.append("Meth "); break;
	            case Obj.Fld:  sb.append("Fld "); break;
	            case Obj.Prog: sb.append("Prog "); break;

        	}
        
	        sb.append(obj.getName());
	        sb.append(": ");

        	// type 
	        switch (obj.getType().getKind()) 
        	{
	            case Struct.None:   sb.append("notype"); break;
	            case Struct.Int:    sb.append("int"); break;
	            case Struct.Char:   sb.append("char"); break;
	            case Struct.Class:  sb.append("class"); break;
	            case 5:             sb.append("bool"); break;
	            case Struct.Array:  sb.append("Arr of ");
            
                    switch (obj.getType().getElemType().getKind()) 
	            {
                                case Struct.None:   sb.append("notype"); break;
                                case Struct.Int:    sb.append("int"); break;
                                case Struct.Char:   sb.append("char"); break;
                                case Struct.Class:  sb.append("class"); break;
                                case 5:             sb.append("bool"); break;
                                default: break;
                    }
            
        	    default: break;
	        }

	        sb.append(", ");
	        sb.append(obj.getAdr());
        	sb.append(", ");
	        sb.append(obj.getLevel());

        	return sb.toString();
    	}

	
	// Add constant: const int = 1...
	void addConstant(String name, Obj con, int line) {
		if (name == null || con == null || currType == null || currTypeName == null) return;

		if (currType.getKind() != con.getType().getKind()) {
			printError(Message.SemanticError.wrongType(currTypeName, line));
			return;
		}
		
		// if name is declared name, print error
		if (isDeclared(name)) {
			printError(Message.SemanticError.alreadyDeclared(name, line));
			return;
		}
		//handle string type
		if (con.getType() == parser.stringType) {
			Obj var = parser.insert_symbol(Obj.Var, name, con.getType());
			var.setLevel(0); // global

			//StringCode.put(Code.putstatic);
			//StringCode.put2(var.getAdr());

			return;
		}
		
		Obj obj = parser.insert_symbol(Obj.Con, name, con.getType());
		obj.setAdr(con.getAdr());
		parser.globalConstantsCount++;
		parser.report_info(Message.SemanticMessage.constVarDecl(obj, line));
	}

	// Add global: int x, xy[];
	void addGlobal(String name, int line, boolean isArray) {
		if (name == null || currType == null || currTypeName == null) return;

		// if name is declared, print error
		if (isDeclared(name)) {
			printError(Message.SemanticError.alreadyDeclared(name, line));
			return;
		}

		Obj temp = null;
		if (isArray) {
			temp = Tab.insert(Obj.Var, name, new Struct(Struct.Array, currType));
			parser.globalArrayDeclCount++;
		} else {
			temp = Tab.insert(Obj.Var, name, currType);
			parser.globalVariablesCount++;
		}

		parser.report_info(Message.SemanticMessage.globalVarDecl(temp, line));
		
	}

	// Add local variables
	void addLocal(String name, int line, boolean isArray) {
		if (name == null || currType == null || currMethod == null) {
			return;
		}
		
		if (!isDeclared(name)) {
			Obj temp = null;
			if (isArray) {
				Tab.insert(Obj.Var, name, new Struct(Struct.Array, currType));
			} else {
				Tab.insert(Obj.Var, name, currType);
			}
		} else {
			printError(Message.SemanticError.alreadyDeclared(name, line));
		}
	}

	// Add formal parameter to current scope
	void addFormalParam(String name, int line, boolean isArray) {
		if (name == null || currType == null || currMethod == null) return;
		
		if (isDeclared(name)) {
			printError(Message.SemanticError.alreadyDeclared(name, line));
		} else {
			Obj temp = null;
			
			if (isArray) {
				temp = Tab.insert(Obj.Var, name, new Struct(Struct.Array, currType));
			} else {
				temp = Tab.insert(Obj.Var, name, currType);
			}
			if (currMethod != null) {
				currMethod.setLevel(currMethod.getLevel() + 1);
				if (currClass != null) {
					temp.setAdr(temp.getAdr() + 1);
				}
			}
				
		}
	}

	// Add class field
	void addClassField(String name, int line, boolean isArray) {
		if (name == null || currClass == null || currType == null) {
			return;
		}

		if (!isDeclared(name)) {
			Obj temp = null;
			
			temp = Tab.insert(Obj.Fld, name, isArray ? new Struct(Struct.Array, currType) : currType);

			currClass.setAdr(currClass.getAdr() + 1);
			temp.setAdr(currClass.getAdr());

			parser.report_info(Message.SemanticMessage.fieldDecl(temp, line));
		} else {
			printError(Message.SemanticError.alreadyDeclared(name, line));
		}
	}

	boolean isDeclared(String name) {
		if (name  == null) {
			return true;
		}

		Obj temp = Tab.find(name);
		if (temp.getKind() == Obj.Type) {
			return true; //int int;
		}

		temp = Tab.currentScope.findSymbol(name);
		return temp != Tab.noObj && temp != null;
	}

:}

init with {:
	Tab.init();

	stringType.setElementType(Tab.charType);
	
	Tab.currentScope.addToLocals(new Obj (Obj.Type, "string", stringType));
	Tab.currentScope.addToLocals(new Obj (Obj.Type, "bool", boolType));
:}


terminal PROG, LBRACE, RBRACE, LPAREN, RPAREN, CONST, SEMI, ASSIGN, COMMA, VOID;
terminal LBRACKET, RBRACKET, CLASS, EXTENDS, WHILE;
terminal READ, BREAK, RETURN, PRINT, DO, IF, ELSE, INCREMENT, DECREMENT, AND, OR;
terminal DOT, MINUS, NEW, PLUS, EQUALS, NEQUALS, MORE, MOREQUAL, LESS, LESSEQUAL;
terminal TIMES, DIV, PERCENT;

// Const Literals
terminal Integer NUMBER;
terminal Character CHAR;
terminal String BOOLCONST;
terminal String STRCONST;

// Identifiers
terminal String IDENT;

non terminal Program, ConstDecl;
non terminal VarDecl, VarDeclList, ClassDecl, ConstDefList;
non terminal VarDefList, VarDef, VarMethodDeclList, MethodDecl;
non terminal Statement, StatementList, matched, unmatched, FormPars;
non terminal FormParam, LvalueOperator, Condition, Cond, ActPars;
non terminal CondFact, CondTerm, AddopTermList;
non terminal FunctionDeclList, FunctionDecl, EndOfFunction, Function;
non terminal GlobalDeclList, GlobalDecl, GlobalConstDecl, GlobalVarDecl, GlobalVarDefList, GlobalVarDef;
non terminal Extends, ClassVarDecl, ClassVarDefList, ClassVarDef;
non terminal String Ident;


non terminal Integer Relop, Addop, Mulop;
// Semantic
non terminal Obj ProgramName, ConstLiteral, FuncName, IdentList, Designator, ClassName;
non terminal Obj Type, Expr, Term, Factor, FuncCall, StrConst;

Program ::= PROG ProgramName:p GlobalDeclList LBRACE FunctionDeclList RBRACE {:
		Tab.chainLocalSymbols(p);
		Tab.closeScope();

		if (!mainDetected) {
			printError(Message.SemanticError.noMainDetected);
		}
	:}
	;

ProgramName ::= IDENT:pName {:
		RESULT = parser.insert_symbol(Obj.Prog, pName, Tab.noType);

		Tab.openScope();
	:}
	;

GlobalDeclList ::= GlobalDecl
		GlobalDeclList
		| /* epsilon */
		;

GlobalDecl ::= GlobalConstDecl
	| GlobalVarDecl
	| ClassDecl {:
		parser.innerClassCount++;
	:}
	;

GlobalConstDecl ::= CONST Type ConstDefList SEMI
		| CONST error SEMI
		;

ConstDefList ::= ConstDecl
		| ConstDecl COMMA ConstDefList
		;

ConstDecl ::= IDENT:name ASSIGN ConstLiteral:con {:
		addConstant(name, con, nameleft);
	:}
	;

ConstLiteral ::= NUMBER:n {:
			Obj con = new Obj(Obj.Con, "", Tab.intType);
			con.setAdr(n.intValue());
			RESULT = con;
		:}
		| CHAR:c {:
			Obj con = new Obj(Obj.Con, "", Tab.charType);
			con.setAdr(c.charValue());
			RESULT = con; 
		:}
		| BOOLCONST:b {:
			Obj con = new Obj(Obj.Con, "", parser.boolType);
			con.setAdr(b.equals("true") ? 1 : 0);
			RESULT = con;
		:}
		| STRCONST:i {:
			Obj con = new Obj(Obj.Con, "", parser.stringType);

			// allocate on heap - len bytes
			StringCode.loadConst(i.length());
			StringCode.put(Code.newarray);
			StringCode.put(0);

			// address on stack
			for (int index = 0; index < i.length(); index++)
			{
			    StringCode.put(Code.dup); // duplicate, bastore removes address
			    StringCode.loadConst(index);
			    StringCode.loadConst(i.charAt(index));
			    StringCode.put(Code.bastore);
			}

			RESULT = con;
		:}
		;

StrConst ::= STRCONST:i {:
		Obj con = new Obj(Obj.Con, "", parser.stringType);
		// Allocate on heap
		Code.loadConst(i.length());
		Code.put(Code.newarray);
		Code.put(0);

		for (int j = 0; j < i.length(); j++) {
			Code.put(Code.dup);
			Code.loadConst(j);
			Code.loadConst(i.charAt(j));
			Code.put(Code.bastore);
		}

		RESULT = con;

	:}
	;

GlobalVarDecl ::= Type GlobalVarDefList SEMI
		| Type error SEMI
		;

GlobalVarDefList ::= GlobalVarDef
		| GlobalVarDef COMMA GlobalVarDefList
		;

GlobalVarDef ::= Ident:id {:
			addGlobal(id, idleft, false);
		:}
		| Ident:id LBRACKET RBRACKET {:
			addGlobal(id, idleft, true);
		:}
		;

VarDecl ::= Type VarDefList SEMI
	| Type error SEMI
	| Type error LBRACE
	;

VarDefList ::= VarDef
		| VarDef COMMA VarDefList
		;

VarDef ::= Ident:n {: addLocal(n, nleft, false); :}
	| Ident:n {: addLocal(n, nleft, true); :} LBRACKET RBRACKET
	;

ClassDecl ::= CLASS ClassName:id Extends LBRACE VarMethodDeclList RBRACE {:
		if (id != null) {
			Tab.chainLocalSymbols(id.getType());
			Tab.closeScope();
		}

		currClass = null;
	:}
	| CLASS Ident error LBRACE VarMethodDeclList RBRACE
	| CLASS error RBRACE
	;

ClassName ::= IDENT:id {:
		Obj temp = null;
		
		if (!isDeclared(id)) {
			temp = new Obj(Obj.Type, id, new Struct(Struct.Class));

			// add class to the list

			Tab.currentScope.addToLocals(temp);
			Tab.openScope();

			parser.report_info(Message.SemanticMessage.classDecl(temp, idleft));

			temp.getType().setElementType(null);
			temp.setAdr(0);
		} else {
			printError(Message.SemanticError.alreadyDeclared(id, idleft));
		}


		currClass = temp;
	        RESULT = temp;
	:}
	;


Extends ::= EXTENDS Type:inherit {:
		if (currTypeName != null && currClass != null && inherit != null) {
			if (currTypeName.equals(currClass.getName())) {
				printError(Message.SemanticError.selfInheritance(inheritleft));
			} else {
				currClass.getType().setElementType(inherit.getType());
				currClass.setAdr(inherit.getAdr());
			}
		}
	:}
	| /* epsilon */
	;

VarMethodDeclList ::= ClassVarDecl VarMethodDeclList
		| MethodDecl {:
			parser.innerClassMethodCount++;
		:} VarMethodDeclList
		| /* epsilon */
		;

ClassVarDecl ::= Type ClassVarDefList SEMI
		;

ClassVarDefList ::= ClassVarDef
		| ClassVarDef COMMA ClassVarDefList
		;

ClassVarDef ::= Ident:id {:
			addClassField(id, idleft, false);
		:}
		| Ident:id LBRACKET RBRACKET {:
			addClassField(id, idleft, true);
		:}
		;


MethodDecl ::= Type FuncName:m LPAREN FormPars RPAREN VarDeclList LBRACE {:
		if (m != null && currMethod != null) {
			Tab.chainLocalSymbols(currMethod);
		}

	:}
		 StatementList RBRACE EndOfFunction {:

			if (currMethod != null) {
				Tab.closeScope();
			}
			parser.statementBlocksCount++;
	:}
	| VOID {: currType = Tab.noType; :} FuncName:m LPAREN FormPars RPAREN VarDeclList LBRACE {:
		if (m != null && currMethod != null) {
			Tab.chainLocalSymbols(currMethod);
		}
	:}
	StatementList RBRACE EndOfFunction {:
		parser.statementBlocksCount++;
	:}
	;


FunctionDecl ::= Type Function:fn {:
		if (fn != null && currMethod != null) {
			Tab.chainLocalSymbols(currMethod);
		}
		if (currMethod != null) {
			Tab.closeScope();
		}
		parser.statementBlocksCount++;
	:}
	| VOID {: currType = Tab.noType; :} Function:fn {:
		if (fn != null && currMethod != null) {
			Tab.chainLocalSymbols(currMethod);
		}

		parser.statementBlocksCount++;
	:}
	;

Function ::= FuncName:fn LPAREN FormPars RPAREN VarDeclList {: 
		if (fn != null && currMethod != null) {
			Tab.chainLocalSymbols(currMethod);
			returnFound = false;		
			Code.put(Code.enter);
			Code.put(currMethod.getLevel());
			Code.put(Tab.currentScope.getnVars());
		}
	:}
	LBRACE StatementList RBRACE {:
		if (fn != null && currMethod != null) {
			/*if (m.getType() != Tab.noType && !returnFound) {

			}*/
			
			parser.statementBlocksCount++;
			
			Tab.closeScope();
			
			if (currMethod.getType() == Tab.noType && returnFound == false) {
				Code.put(Code.exit);
				Code.put(Code.return_);
			}
			currMethod = null;
		}
	:} EndOfFunction
	;

FuncName ::= IDENT:fname {:
		
		currMethod = null;

		if(!isDeclared(fname)) {
			currMethod = Tab.insert(Obj.Meth, fname, currType);
			currMethod.setLevel(0);
			currMethod.setAdr(Code.pc);
			Tab.openScope();
		} else {
			printError(Message.SemanticError.alreadyDeclared(fname, fnameleft));
		}

		if (currMethod != null && fname.equals("main")) {
			if (currType != Tab.noType) {
				printError(Message.SemanticError.mainFunctionErr(fnameleft));
			} else {
				inMain = true;
				mainDetected = true;
				Code.mainPc = currMethod.getAdr(); //set main PC
				
				// store global const strings
				for (int i = 0; i < StringCode.size(); i++)
					Code.buf[Code.pc++] = (StringCode.getBuffer())[i];
			}
			
		}

		RESULT = currMethod;
	:}
	;

EndOfFunction ::= {:
		:} 
		/* epsilon */
		;

FunctionDeclList ::= FunctionDecl {:
			parser.functionDefinitionCount++;
		:} FunctionDeclList
		| /* epsilon */
		;

VarDeclList ::= VarDecl VarDeclList
		| /* epsilon */
		;

FormPars ::= FormParam
	| FormParam COMMA FormPars
	| error
	| /* epsilon */
	;

FormParam ::= Type Ident:name {: if(inMain) printError(Message.SemanticError.mainFunctionErr(nameleft)); addFormalParam(name, nameleft, false); :}
		| Type Ident:name LBRACKET RBRACKET {: if(inMain) printError(Message.SemanticError.mainFunctionErr(nameleft)); addFormalParam(name, nameleft, true); :}
		;


StatementList ::= Statement {:
			if (inMain) {
				parser.statementsInMainCount++;
			}
		:}
		 StatementList
		| /* epsilon */
		;

Statement ::= matched
	| unmatched
	;

matched ::= Designator:d ASSIGN Expr:e  {:
		if (d != null && e != null) {
			if (!parser.isLvalueVariable(d)) {
				printError(Message.SemanticError.assignToConst(d, dleft));
			}
			
			Struct t1 = d.getType();
			Struct t2 = e.getType();

			if (!t2.assignableTo(t1)) {
				printError(Message.SemanticError.wrongType(d.getName(), dleft));
			}

			Code.store(d);

		}
		:} SEMI
		| Designator:d INCREMENT SEMI {:
			if (d != null) {
				if (d.getKind() == Obj.Con) {
					printError(Message.SemanticError.assignToConst(d, dleft));
				}

				if (d.getType() != Tab.intType) {
					printError(Message.SemanticError.onlyInteger(dleft));
				} else {
					Code.load(d);
					Code.loadConst(1);
					Code.put(Code.add);
					Code.store(d);
				}
			}
		:}
		| Designator:d DECREMENT SEMI {:
			if (d != null) {
				if (d.getKind() == Obj.Con) {
					printError(Message.SemanticError.assignToConst(d, dleft));
				}

				if (d.getType() != Tab.intType) {
					printError(Message.SemanticError.onlyInteger(dleft));
				} else {
					Code.load(d);
					Code.loadConst(1);
					Code.put(Code.sub);
					Code.store(d);
				}
			}
		:}
		| Designator ASSIGN error SEMI
		| FuncCall LPAREN RPAREN SEMI
		| FuncCall:f LPAREN ActPars RPAREN SEMI {:
			//end of function call
			generateFunctionCall(f, fleft);

			if (f != null) {
				if (f.getType() != Tab.noType) {
					// pop return value
				}
			}
		:}
		| FuncCall LPAREN error RPAREN SEMI
		| READ LPAREN Designator RPAREN SEMI
		| BREAK SEMI 
		| RETURN:r SEMI {:
			if (currMethod != null) {
				returnFound = true;

				if (currMethod.getType() != Tab.noType) {
					printError(Message.SemanticError.wrongRetValue(currMethod.getName(), rleft));
				} else {
					Code.put(Code.exit);
					Code.put(Code.return_);
				}
			}
		:}
		| RETURN Expr:e SEMI {:
			if (currMethod != null && e != null) {
				Struct t = e.getType();
				returnFound = true;

				if (!t.compatibleWith(currMethod.getType())) {
					printError(Message.SemanticError.wrongRetValue(currMethod.getName(), eleft));
				} else {
					Code.put(Code.exit);
					Code.put(Code.return_);
				}
			}
		:}
		| PRINT LPAREN Expr:expr RPAREN SEMI {:
			if (expr != null) {
				Struct type = expr.getType();
				if (type == Tab.intType) {
					Code.loadConst(5);
					Code.put(Code.print);
				} else if (type == Tab.charType) {
					Code.loadConst(1);
					Code.put(Code.bprint);
				} else if (type == parser.boolType) {
					Code.loadConst(1);
					Code.put(Code.bprint);
				} else if(type == parser.stringType) {
					// Unsuported
				} else {
					printError(Message.SemanticError.wrongParams("print", exprleft));
				}
			}
		:}
		| PRINT LPAREN Expr:expr COMMA NUMBER:i RPAREN SEMI {:
			if (expr != null) {
				Struct type = expr.getType();
				if (type == Tab.intType) {
					Code.loadConst(i);
					Code.put(Code.print);
				} else if (type == Tab.charType) {
					Code.loadConst(i);
					Code.put(Code.bprint);
				} else if (type == parser.boolType) {
					Code.loadConst(i);
					Code.put(Code.bprint);
				} else if(type == parser.stringType) {
					// Unsuported
				} else {
					printError(Message.SemanticError.wrongParams("print", exprleft));
				}
			}
		:}
		| LBRACE StatementList RBRACE {:
			parser.statementBlocksCount++;
		:}
		| DO matched WHILE Cond SEMI
		| IF Cond matched ELSE matched
		| WHILE Cond matched
		;


unmatched ::= IF Cond Statement
	| IF Cond matched  ELSE unmatched
	| WHILE Cond unmatched
	;

Cond ::= LPAREN Condition RPAREN
	| LPAREN error RPAREN
	;

ActPars ::= Expr:e {:
		addActualParam(e);	
	:}
	| Expr:e COMMA {:
		addActualParam(e);	
	:} ActPars
	| Expr COMMA error COMMA
	| Expr COMMA error RPAREN
	;

Condition ::= CondTerm
	| CondTerm OR Condition
	;

CondTerm ::= CondFact
	| CondFact AND CondTerm
	;

CondFact ::= Expr:expr {:
		//The lonely boolean
		Struct res = Tab.noType;
		if (expr != null) {
			if (!expr.getType().equals(parser.boolType)) {
				printError(Message.SemanticError.onlyBoolean(exprleft));
			} else {
				res = parser.boolType;
			}

			// Code gen bool == 1
			
		}

		RESULT = res;
	:}
	| Expr:expr1 Relop:op Expr:expr2 {:
		Struct res = Tab.noType;
		
		if (expr1 != null && expr2 != null) {
			if (op == Code.eq || op == Code.ne) {
				System.out.println("EXPR1: " + expr1.getName() + "   EXPR2: " + expr2.getName());
				if (!expr1.getType().equals(expr2.getType())) {
					printError(Message.SemanticError.cannotCompare(opleft));
				} else {
					// fix after while or if
				}
			} else {
				System.out.println("EXPR1: " + expr1.getName() + "   EXPR2: " + expr2.getName());
				if (!expr1.getType().equals(expr2.getType()) || expr1.getType() != Tab.intType) {
					printError(Message.SemanticError.cannotCompare(opleft));
				} else {
					// Fix after while or if
				}
			}
			res = parser.boolType;
		}
		RESULT = res;
		
	:}
	;

Expr ::= Expr:e Addop:op Term:t {:
		if (e != null && t != null && op != null) {
			if (e.getType().equals(t.getType()) && t.getType() == Tab.intType) {
				 Code.put(op);
				RESULT = e;
			} else if (t.getType().equals(e.getType()) && t.getType() == parser.stringType && op == Code.add) {
				// Call generated function for addString
				RESULT = e;
			} else {
				printError(Message.SemanticError.wrongType(currTypeName, eleft));
				RESULT = null;
			}
		}
	:}
	| MINUS Term:t {:
		if (t != null) {
			if (t.getType() != Tab.intType) {
				printError(Message.SemanticError.onlyInteger(tleft));
			}
			Code.put(Code.neg);
		}
		RESULT = t;
	:}
	| Term:t  {:
		RESULT = t;
	:}
	;

Type ::= IDENT:t {:
		Obj obj = Tab.find(t);

		currType = null;

		if (obj == Tab.noObj) {
			printError(Message.SemanticError.noTypeErr(t, tleft));
			RESULT = null;
		} else {
			if (Obj.Type == obj.getKind()) {
				currType = obj.getType();
				currTypeName = t;
				RESULT = obj;
			} else {
				printError(Message.SemanticError.typeErr(t, tleft));
				RESULT = null;
			}
		}
	:}
	;

Term ::= Factor:f {:
		RESULT = f;
	:}
	| Factor:f Mulop:op Term:t {:
		if (t != null && f != null) {
			if (t.getType().equals(f.getType()) && t.getType() == Tab.intType) {
				Code.put(op);
				RESULT = t;
			} else {
				RESULT = null;
				printError(Message.SemanticError.wrongType(currTypeName, tleft));
			}
		}
	:}
	;

Factor ::= NUMBER:i {:
		Obj obj = new Obj(Obj.Con, "", Tab.intType);
		obj.setAdr(i);
		Code.load(obj);

		RESULT = obj;
	:}
	| CHAR:i {:
		Obj obj = new Obj(Obj.Con, "", Tab.charType);

		obj.setAdr(i);
		Code.load(obj);
		RESULT = obj;
	:}
	| LPAREN Expr:e {:
		RESULT = e;
	:} RPAREN
	| BOOLCONST:i {:
		Obj obj = new Obj(Obj.Con, "", parser.boolType);
		
		obj.setAdr(i.equals("true") ? 1 : 0);
		Code.load(obj);
		RESULT = obj;
	:}
	| STRCONST:i {:
		Obj con = new Obj(Obj.Con, "", parser.stringType);

                // allocate on heap - len bytes
                Code.loadConst(i.length());
                Code.put(Code.newarray);
                Code.put(0);

                // address on stack
                for (int index = 0; index < i.length(); index++)
                {
                    Code.put(Code.dup); // duplicate, bastore removes address
                    Code.loadConst(index);
                    Code.loadConst(i.charAt(index));
                    Code.put(Code.bastore);
                }

		RESULT = con;
	:}
	| NEW Type:t {:
		if (t != null) {
			if (t.getType().getKind() != Struct.Class) {
				printError(Message.SemanticError.wrongType(t.getName(), tleft));
			} else {		

				Code.put(Code.new_);
				Code.put2(t.getType().getNumberOfFields() * 4);

				parser.instatiationStatementCount++;
			}
		}
		RESULT = t;
	:}
	| NEW Type:t LBRACKET Expr:expr RBRACKET {:
		if (expr != null && expr.getType() != Tab.intType) {
			printError(Message.SemanticError.onlyInteger(exprleft));
		} else {
			Obj array = new Obj(Obj.Elem, t.getName(), new Struct(Struct.Array, t.getType()));

			Code.put(Code.newarray);
			if (t.getType() == Tab.charType) {
				Code.put(0);
			} else {
				Code.put(1);
			}

			parser.instatiationStatementCount++;

			RESULT = array;
		}
	:}
	| Designator:d {:
		if (d != null) {
			Code.load(d);
		}
		RESULT = d;
	:}
	| FuncCall:f LPAREN RPAREN {:
		RESULT = f;
	:}
	| FuncCall:f LPAREN ActPars RPAREN {:
		if (f != null) {
			generateFunctionCall(f, fleft);
		}
		RESULT = f;
	:}
	;

FuncCall ::= Designator:l {:
		if (inMain) {
			parser.fcallInMainCount++;
		}

		if (l != null) {
			if (Obj.Meth == l.getKind()) {
				if (currClass != null && isFunctionCall) { //not in class and its not IDENT.IDENT
					parser.report_info(Message.SemanticMessage.functionCalled(l.getName(), lleft));
				} else {
					parser.report_info(Message.SemanticMessage.methodCalled(l.getName(), lleft));
				}
			} else {
				printError(Message.SemanticError.notFunction(l.getName(), lleft));
			}
		}
		RESULT = l;
	:}
	;


Designator ::= IdentList:id {:
		RESULT = id;
	:}
	;

IdentList ::= IdentList:il DOT Ident:id {:
		Obj member = null;

		if (il != null) {
			if (il.getType().getKind() != Struct.Class) {
				printError(Message.SemanticError.notObject(il.getName(), illeft));
			} else {
				Struct type = il.getType();

				if (currClass != null) {
					member = Tab.currentScope.getOuter().findSymbol(id);
				}

				while(type != null && member == null) {
					for (Obj obj : type.getMembers()) {
						if (id.equals(obj.getName())) {
							member = obj;
							break;
						}
					}
					type = type.getElemType();
				}


			}

			if (member == null) {
				printError(Message.SemanticError.memberNotFound(id, illeft));
			} else {
				if (member.getKind() == Obj.Meth) {
					//set calling 
					callingObjAddressStack.push(il);
					isFunctionCall = false;
				}

				if (il.getKind() != Obj.Type) {
					Code.load(il);
				} else {
					if (member.getKind() == Obj.Fld || member.getKind() == Obj.Meth) {
						Code.put(Code.load_n + 0);
					}
				}
			}
		}

		RESULT = member;
	:}
	| IdentList:ident LBRACKET {:
		if (ident != null) {
			if (ident.getType().getKind() != Struct.Array) {
				printError(Message.SemanticError.wrongType(ident.getName(), identleft));
			} else {
				Code.load(ident);
			}
			
			RESULT = new Obj(Obj.Elem, ident.getName(), ident.getType().getElemType());
		}
	:} Expr:expr RBRACKET {:
		if (expr != null) {
			if (expr.getType() != Tab.intType) {
				printError(Message.SemanticError.onlyInteger(exprleft));
			}
		}
	:}
	| IdentList LBRACKET error RBRACKET
	| Ident:id {:
		Obj obj = null;		
		
		// local
		obj = Tab.currentScope.findSymbol(id);

		// find in class
		if (obj == null && currClass != null) {
			Struct type = currClass.getType();

			obj = Tab.currentScope.getOuter().findSymbol(id);

			while (type != null && obj == null) {
				for (Obj field : type.getMembers()) {
					if (id.equals(field.getName())) {
						obj = field;
						break;
					}
				}
			}

			if (id.equals("this")) {
				obj = currClass;
			}
		}

		// global
		if (obj == null) {
			obj = Tab.find(id);
		}

		// symbol not found
		if (obj == Tab.noObj || obj == null) {
			obj = null;
			printError(Message.SemanticError.nameNotDeclaredErr(id, idleft));
		} else if (obj.getKind() != Obj.Meth) {
			isFunctionCall = true;
			parser.report_info(Message.SemanticMessage.symbolFound(obj, idleft));
		}

		// load this
		if (obj != null && currClass != null) {
			if (obj.getKind() == Obj.Fld) {
				Code.put(Code.load_n + 0);
			} else if (obj.getKind() == Obj.Meth) {
				Code.put(Code.load_n + 0);
				callingObjAddressStack.push(currClass);

				isFunctionCall = true;
			}
		}

		RESULT = obj;
	:}
	;

Ident ::= IDENT:i {:
		RESULT = i;
	:}
	;

Relop ::= EQUALS {: RESULT = Code.eq; :}
	| NEQUALS {: RESULT = Code.ne; :}
	| MORE {: RESULT = Code.gt; :}
	| MOREQUAL {: RESULT = Code.ge; :}
	| LESS {: RESULT = Code.lt; :}
	| LESSEQUAL {: RESULT = Code.le; :}
	;

Addop ::= PLUS {: RESULT =  Code.add; :}
	| MINUS {: RESULT = Code.sub; :}
	;

Mulop ::= TIMES {: RESULT = Code.mul; :}
	| DIV {: RESULT = Code.div; :}
	| PERCENT {: RESULT = Code.rem; :}
	;


